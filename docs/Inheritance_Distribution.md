# Наследование — распределение богатства и активов

Документ описывает точную логику распределения wealth и активов, реализованную в `InheritanceService`.

## Общая идея
- Все денежные значения при распределении переводятся в минимальные единицы валюты (целые), чтобы избежать проблем с дробным округлением.
- Минимальная единица определяется через `currencyDecimalPlaces` (по умолчанию 2) — фактор минимальной единицы = 10^currencyDecimalPlaces (например, для 2 -> 100).
- Все вычисления распределения происходят в целых минимальных единицах, затем результаты конвертируются обратно в `decimal` для создания игровых событий и сохранения сумм в модели.

## Формулы и шаги (wealth распределение)
1. Конвертировать `household.Wealth` в целое число минимальных единиц:
   - totalUnits = truncate(household.Wealth * minimalUnitFactor)
   - truncate — означает отбрасывание дробной части, чтобы не превысить исходную денежную сумму.

2. Если правило `shares`:
   - Нормализовать доли (негативные/нулевые отсекаются); нормализованные доли суммируются до 1.
   - Для каждого наследника рассчитываем желаемое дробное количество единиц: desired_i = share_i * totalUnits.
   - Выделяем целую часть: floor_i = floor(desired_i), суммируем allocated = sum(floor_i).
   - Остаток remaining = totalUnits - allocated.
   - Раздаём remaining единиц наследникам в порядке убывания дробной части (desired_i - floor_i). Это метод largest-remainder (Hamilton method).
   - Если дробные части равны — порядок определяется последовательностью списка наследников (стабильный порядок входного массива). При желании tie-break можно внедрить детерминированную шифрованную сортировку или случайную раздачу.

3. Если правило `equal_split` или fallback:
   - perFloor = totalUnits / N
   - remainder = totalUnits - perFloor * N
   - Каждый наследник получает perFloor единиц; remaining единиц раздаются случайно: for r in 1..remaining -> pick index = IRandomProvider.NextInt(N) и добавляем +1 выбранному.
   - Для тестируемости в DI может быть подставлен `SeedableRandom` (конструктор может принимать seed) — это делает раздачу детерминированной для одиночных прогонов тестов.

4. После распределения wealth служба обнуляет `household.Wealth = 0m` и создаёт соответствующие `GameEvent`-ы с суммой, форматированной с фиксированной точностью `currencyDecimalPlaces`.

## Распределение активов (Ownership)
- Правило `primogeniture`: все assets передаются первому (старшему) наследнику в списке.
- Правило `shares`: используется метод целочисленного распределения по долям (похож на распределение объектов):
  - desired_assets_i = share_i * totalAssets
  - floor/allocated + largest remainder → назначение целочисленного количества assets каждому наследнику
  - Активы назначаются в стабильном порядке (по `OrderBy(o => o.AssetId)`), чтобы поведение было детерминированным при одинаковых долях.
- Правило `equal_split` / fallback: round-robin (по порядку) назначение assets (детерминированно).

## Events (GameEvent)
- Все игровые события, возникающие при распределении wealth и активов, собираются в память (`createdEvents`) во время транзакции.
- После успешного `tx.Commit()` сервис асинхронно помещает события в `IEventDispatcher.EnqueueAsync(...)`.
  - В продакшене `EventDispatcherService` сохраняет и публикует события в фоне.
  - В тестах используется `TestEventDispatcher`, который синхронно сохраняет события в БД, что позволяет тестам немедленно их проверять.
- Это предотвращает длительные I/O или публикацию отложенных действий внутри открытой транзакции.
- Интеграционные тесты закрывают сценарии с несколькими хозяйствами (deceased как глава и как член) и гарантируют, что на каждый переданный актив создаётся отдельный `inheritance_transfer`.

## Тестирование и детерминированность
- `IRandomProvider` — интерфейс генератора случайных чисел. В продакшене используется `SeedableRandom` без фиксированного семени (Environment.TickCount).
- Для тестов можно зарегистрировать `SeedableRandom` с фиксированным `seed`, чтобы поведение распределения remainder было воспроизводимо.

## Точки улучшения (рекомендации)
- Сделать `currencyDecimalPlaces` конфигурируемым (appsettings), чтобы поддерживать разные валютные единицы.
- Улучшить tie-break при равных дробных частях при shares: можно добавить детерминированную tie-breaker-политику (например, сортировка по хэшу GUID + salt), либо опцию случайного выбора.
- Покрыть дополнительными unit-тестами краевые случаи: очень маленькие wealth (< minimal unit), много наследников, равные дробные остатки, большие суммы (overflow-охраны).

---
Файл с логикой: `src/Imperium.Api/Services/InheritanceService.cs`.
Тестовый диспетчер: `src/Imperium.Api.Tests/TestEventDispatcher.cs`.
Интерфейс RNG: `src/Imperium.Api/Utils/IRandomProvider.cs`.

Если хотите, я могу:
- Сделать `currencyDecimalPlaces` конфигурируемым и обновить тесты;
- Внедрить детерминированный tie-breaker при одинаковых дробях;
- Добавить ещё тестов и вспомогательных логов.

---
Progress update: created `docs/Inheritance_Distribution.md` and updated the todo list (1 marked in-progress). Next I'll mark the docs task done and optionally run tests (not necessary).
